{"ast":null,"code":"let k, v;\nimport { adjacency_graphs } from './adjacency_graphs';\n// on qwerty, 'g' has degree 6, being adjacent to 'ftyhbv'. '\\' has degree 1.\n// this calculates the average over all keys.\nconst calc_average_degree = function (graph) {\n  let average = 0;\n  for (let key in graph) {\n    const neighbors = graph[key];\n    average += Array.from(neighbors).filter(n => n).length;\n  }\n  average /= (() => {\n    const result = [];\n    for (k in graph) {\n      v = graph[k];\n      result.push(k);\n    }\n    return result;\n  })().length;\n  return average;\n};\nconst BRUTEFORCE_CARDINALITY = 10;\nconst MIN_GUESSES_BEFORE_GROWING_SEQUENCE = 10000;\nconst MIN_SUBMATCH_GUESSES_SINGLE_CHAR = 10;\nconst MIN_SUBMATCH_GUESSES_MULTI_CHAR = 50;\nexport class Scoring {\n  static nCk(n, k) {\n    // http://blog.plover.com/math/choose.html\n    if (k > n) {\n      return 0;\n    }\n    if (k === 0) {\n      return 1;\n    }\n    let r = 1;\n    for (let d = 1, end = k, asc = 1 <= end; asc ? d <= end : d >= end; asc ? d++ : d--) {\n      r *= n;\n      r /= d;\n      n -= 1;\n    }\n    return r;\n  }\n  static log10(n) {\n    return Math.log(n) / Math.log(10);\n  }\n  // IE doesn't support Math.log10 :(\n  static log2(n) {\n    return Math.log(n) / Math.log(2);\n  }\n  static factorial(n) {\n    // unoptimized, called only on small n\n    if (n < 2) {\n      return 1;\n    }\n    let f = 1;\n    for (let i = 2, end = n, asc = 2 <= end; asc ? i <= end : i >= end; asc ? i++ : i--) {\n      f *= i;\n    }\n    return f;\n  }\n  // ------------------------------------------------------------------------------\n  // search --- most guessable match sequence -------------------------------------\n  // ------------------------------------------------------------------------------\n  //\n  // takes a sequence of overlapping matches, returns the non-overlapping sequence with\n  // minimum guesses. the following is a O(l_max * (n + m)) dynamic programming algorithm\n  // for a length-n password with m candidate matches. l_max is the maximum optimal\n  // sequence length spanning each prefix of the password. In practice it rarely exceeds 5 and the\n  // search terminates rapidly.\n  //\n  // the optimal \"minimum guesses\" sequence is here defined to be the sequence that\n  // minimizes the following function:\n  //\n  //    g = l! * Product(m.guesses for m in sequence) + D^(l - 1)\n  //\n  // where l is the length of the sequence.\n  //\n  // the factorial term is the number of ways to order l patterns.\n  //\n  // the D^(l-1) term is another length penalty, roughly capturing the idea that an\n  // attacker will try lower-length sequences first before trying length-l sequences.\n  //\n  // for example, consider a sequence that is date-repeat-dictionary.\n  //  - an attacker would need to try other date-repeat-dictionary combinations,\n  //    hence the product term.\n  //  - an attacker would need to try repeat-date-dictionary, dictionary-repeat-date,\n  //    ..., hence the factorial term.\n  //  - an attacker would also likely try length-1 (dictionary) and length-2 (dictionary-date)\n  //    sequences before length-3. assuming at minimum D guesses per pattern type,\n  //    D^(l-1) approximates Sum(D^i for i in [1..l-1]\n  //\n  // ------------------------------------------------------------------------------\n  static most_guessable_match_sequence(password, matches, _exclude_additive) {\n    let guesses, m;\n    let asc4, end4;\n    let _;\n    if (_exclude_additive == null) {\n      _exclude_additive = false;\n    }\n    const n = password.length;\n    // partition matches into sublists according to ending index j\n    const matches_by_j = (() => {\n      let asc, end;\n      const result = [];\n      for (_ = 0, end = n, asc = 0 <= end; asc ? _ < end : _ > end; asc ? _++ : _--) {\n        result.push([]);\n      }\n      return result;\n    })();\n    for (m of Array.from(matches)) {\n      matches_by_j[m.j].push(m);\n    }\n    // small detail: for deterministic output, sort each sublist by i.\n    for (let lst of Array.from(matches_by_j)) {\n      lst.sort((m1, m2) => m1.i - m2.i);\n    }\n    const optimal = {\n      // optimal.m[k][l] holds final match in the best length-l match sequence covering the\n      // password prefix up to k, inclusive.\n      // if there is no length-l sequence that scores better (fewer guesses) than\n      // a shorter match sequence spanning the same prefix, optimal.m[k][l] is undefined.\n      m: (() => {\n        let asc1, end1;\n        const result1 = [];\n        for (_ = 0, end1 = n, asc1 = 0 <= end1; asc1 ? _ < end1 : _ > end1; asc1 ? _++ : _--) {\n          result1.push({});\n        }\n        return result1;\n      })(),\n      // same structure as optimal.m -- holds the product term Prod(m.guesses for m in sequence).\n      // optimal.pi allows for fast (non-looping) updates to the minimization function.\n      pi: (() => {\n        let asc2, end2;\n        const result2 = [];\n        for (_ = 0, end2 = n, asc2 = 0 <= end2; asc2 ? _ < end2 : _ > end2; asc2 ? _++ : _--) {\n          result2.push({});\n        }\n        return result2;\n      })(),\n      // same structure as optimal.m -- holds the overall metric.\n      g: (() => {\n        let asc3, end3;\n        const result3 = [];\n        for (_ = 0, end3 = n, asc3 = 0 <= end3; asc3 ? _ < end3 : _ > end3; asc3 ? _++ : _--) {\n          result3.push({});\n        }\n        return result3;\n      })()\n    };\n    // helper: considers whether a length-l sequence ending at match m is better (fewer guesses)\n    // than previously encountered sequences, updating state if so.\n    const update = (m, l) => {\n      k = m.j;\n      let pi = this.estimate_guesses(m, password);\n      if (l > 1) {\n        // we're considering a length-l sequence ending with match m:\n        // obtain the product term in the minimization function by multiplying m's guesses\n        // by the product of the length-(l-1) sequence ending just before m, at m.i - 1.\n        pi *= optimal.pi[m.i - 1][l - 1];\n      }\n      // calculate the minimization func\n      let g = this.factorial(l) * pi;\n      if (!_exclude_additive) {\n        g += Math.pow(MIN_GUESSES_BEFORE_GROWING_SEQUENCE, l - 1);\n      }\n      // update state if new best.\n      // first see if any competing sequences covering this prefix, with l or fewer matches,\n      // fare better than this sequence. if so, skip it and return.\n      for (let competing_l in optimal.g[k]) {\n        const competing_g = optimal.g[k][competing_l];\n        if (competing_l > l) {\n          continue;\n        }\n        if (competing_g <= g) {\n          return;\n        }\n      }\n      // this sequence might be part of the final optimal sequence.\n      optimal.g[k][l] = g;\n      optimal.m[k][l] = m;\n      return optimal.pi[k][l] = pi;\n    };\n    // helper: evaluate bruteforce matches ending at k.\n    const bruteforce_update = k => {\n      // see if a single bruteforce match spanning the k-prefix is optimal.\n      m = make_bruteforce_match(0, k);\n      update(m, 1);\n      return (() => {\n        const result4 = [];\n        for (var i = 1, end4 = k, asc4 = 1 <= end4; asc4 ? i <= end4 : i >= end4; asc4 ? i++ : i--) {\n          // generate k bruteforce matches, spanning from (i=1, j=k) up to (i=k, j=k).\n          // see if adding these new matches to any of the sequences in optimal[i-1]\n          // leads to new bests.\n          m = make_bruteforce_match(i, k);\n          result4.push((() => {\n            const result5 = [];\n            const object = optimal.m[i - 1];\n            for (let l in object) {\n              const last_m = object[l];\n              l = parseInt(l);\n              // corner: an optimal sequence will never have two adjacent bruteforce matches.\n              // it is strictly better to have a single bruteforce match spanning the same region:\n              // same contribution to the guess product with a lower length.\n              // --> safe to skip those cases.\n              if (last_m.pattern === 'bruteforce') {\n                continue;\n              }\n              // try adding m to this length-l sequence.\n              result5.push(update(m, l + 1));\n            }\n            return result5;\n          })());\n        }\n        return result4;\n      })();\n    };\n    // helper: make bruteforce match objects spanning i to j, inclusive.\n    var make_bruteforce_match = (i, j) => {\n      return {\n        pattern: 'bruteforce',\n        token: password.slice(i, +j + 1 || undefined),\n        i,\n        j\n      };\n    };\n    // helper: step backwards through optimal.m starting at the end,\n    // constructing the final optimal match sequence.\n    const unwind = n => {\n      const optimal_match_sequence = [];\n      k = n - 1;\n      // find the final best sequence length and score\n      let l = undefined;\n      let g = Infinity;\n      for (let candidate_l in optimal.g[k]) {\n        const candidate_g = optimal.g[k][candidate_l];\n        if (candidate_g < g) {\n          l = candidate_l;\n          g = candidate_g;\n        }\n      }\n      while (k >= 0) {\n        m = optimal.m[k][l];\n        optimal_match_sequence.unshift(m);\n        k = m.i - 1;\n        l--;\n      }\n      return optimal_match_sequence;\n    };\n    for (k = 0, end4 = n, asc4 = 0 <= end4; asc4 ? k < end4 : k > end4; asc4 ? k++ : k--) {\n      for (m of Array.from(matches_by_j[k])) {\n        if (m.i > 0) {\n          for (let l in optimal.m[m.i - 1]) {\n            l = parseInt(l);\n            update(m, l + 1);\n          }\n        } else {\n          update(m, 1);\n        }\n      }\n      bruteforce_update(k);\n    }\n    const optimal_match_sequence = unwind(n);\n    const optimal_l = optimal_match_sequence.length;\n    // corner: empty password\n    if (password.length === 0) {\n      guesses = 1;\n    } else {\n      guesses = optimal.g[n - 1][optimal_l];\n    }\n    // final result object\n    return {\n      password,\n      guesses,\n      guesses_log10: this.log10(guesses),\n      sequence: optimal_match_sequence\n    };\n  }\n  // ------------------------------------------------------------------------------\n  // guess estimation -- one function per match pattern ---------------------------\n  // ------------------------------------------------------------------------------\n  static estimate_guesses(match, password) {\n    if (match.guesses != null) {\n      return match.guesses;\n    } // a match's guess estimate doesn't change. cache it.\n    let min_guesses = 1;\n    if (match.token.length < password.length) {\n      min_guesses = match.token.length === 1 ? MIN_SUBMATCH_GUESSES_SINGLE_CHAR : MIN_SUBMATCH_GUESSES_MULTI_CHAR;\n    }\n    const estimation_functions = {\n      bruteforce: this.bruteforce_guesses,\n      dictionary: this.dictionary_guesses,\n      spatial: this.spatial_guesses,\n      repeat: this.repeat_guesses,\n      sequence: this.sequence_guesses,\n      regex: this.regex_guesses,\n      date: this.date_guesses\n    };\n    const guesses = estimation_functions[match.pattern].call(this, match);\n    match.guesses = Math.max(guesses, min_guesses);\n    match.guesses_log10 = this.log10(match.guesses);\n    return match.guesses;\n  }\n  static bruteforce_guesses(match) {\n    let guesses = Math.pow(BRUTEFORCE_CARDINALITY, match.token.length);\n    if (guesses === Number.POSITIVE_INFINITY) {\n      guesses = Number.MAX_VALUE;\n    }\n    // small detail: make bruteforce matches at minimum one guess bigger than smallest allowed\n    // submatch guesses, such that non-bruteforce submatches over the same [i..j] take precedence.\n    const min_guesses = match.token.length === 1 ? MIN_SUBMATCH_GUESSES_SINGLE_CHAR + 1 : MIN_SUBMATCH_GUESSES_MULTI_CHAR + 1;\n    return Math.max(guesses, min_guesses);\n  }\n  static repeat_guesses(match) {\n    return match.base_guesses * match.repeat_count;\n  }\n  static sequence_guesses(match) {\n    let base_guesses;\n    const first_chr = match.token.charAt(0);\n    // lower guesses for obvious starting points\n    if (['a', 'A', 'z', 'Z', '0', '1', '9'].includes(first_chr)) {\n      base_guesses = 4;\n    } else {\n      if (first_chr.match(/\\d/)) {\n        base_guesses = 10; // digits\n      } else {\n        // could give a higher base for uppercase,\n        // assigning 26 to both upper and lower sequences is more conservative.\n        base_guesses = 26;\n      }\n    }\n    if (!match.ascending) {\n      // need to try a descending sequence in addition to every ascending sequence ->\n      // 2x guesses\n      base_guesses *= 2;\n    }\n    return base_guesses * match.token.length;\n  }\n  static regex_guesses(match) {\n    const char_class_bases = {\n      alpha_lower: 26,\n      alpha_upper: 26,\n      alpha: 52,\n      alphanumeric: 62,\n      digits: 10,\n      symbols: 33\n    };\n    if (match.regex_name in char_class_bases) {\n      return Math.pow(char_class_bases[match.regex_name], match.token.length);\n    } else {\n      switch (match.regex_name) {\n        case 'recent_year':\n          // conservative estimate of year space: num years from REFERENCE_YEAR.\n          // if year is close to REFERENCE_YEAR, estimate a year space of MIN_YEAR_SPACE.\n          var year_space = Math.abs(parseInt(match.regex_match[0]) - this.REFERENCE_YEAR);\n          year_space = Math.max(year_space, this.MIN_YEAR_SPACE);\n          return year_space;\n      }\n    }\n  }\n  static date_guesses(match) {\n    // base guesses: (year distance from REFERENCE_YEAR) * num_days * num_years\n    const year_space = Math.max(Math.abs(match.year - this.REFERENCE_YEAR), this.MIN_YEAR_SPACE);\n    let guesses = year_space * 365;\n    // add factor of 4 for separator selection (one of ~4 choices)\n    if (match.separator) {\n      guesses *= 4;\n    }\n    return guesses;\n  }\n  static spatial_guesses(match) {\n    let d, i, s;\n    let asc, end;\n    if (['qwerty', 'dvorak'].includes(match.graph)) {\n      s = this.KEYBOARD_STARTING_POSITIONS;\n      d = this.KEYBOARD_AVERAGE_DEGREE;\n    } else {\n      s = this.KEYPAD_STARTING_POSITIONS;\n      d = this.KEYPAD_AVERAGE_DEGREE;\n    }\n    let guesses = 0;\n    const L = match.token.length;\n    const t = match.turns;\n    // estimate the number of possible patterns w/ length L or less with t turns or less.\n    for (i = 2, end = L, asc = 2 <= end; asc ? i <= end : i >= end; asc ? i++ : i--) {\n      const possible_turns = Math.min(t, i - 1);\n      for (let j = 1, end1 = possible_turns, asc1 = 1 <= end1; asc1 ? j <= end1 : j >= end1; asc1 ? j++ : j--) {\n        guesses += this.nCk(i - 1, j - 1) * s * Math.pow(d, j);\n      }\n    }\n    // add extra guesses for shifted keys. (% instead of 5, A instead of a.)\n    // math is similar to extra guesses of l33t substitutions in dictionary matches.\n    if (match.shifted_count) {\n      const S = match.shifted_count;\n      const U = match.token.length - match.shifted_count; // unshifted count\n      if (S === 0 || U === 0) {\n        guesses *= 2;\n      } else {\n        let asc2, end2;\n        let shifted_variations = 0;\n        for (i = 1, end2 = Math.min(S, U), asc2 = 1 <= end2; asc2 ? i <= end2 : i >= end2; asc2 ? i++ : i--) {\n          shifted_variations += this.nCk(S + U, i);\n        }\n        guesses *= shifted_variations;\n      }\n    }\n    return guesses;\n  }\n  static dictionary_guesses(match) {\n    match.base_guesses = match.rank; // keep these as properties for display purposes\n    match.uppercase_variations = this.uppercase_variations(match);\n    match.l33t_variations = this.l33t_variations(match);\n    const reversed_variations = match.reversed && 2 || 1;\n    return match.base_guesses * match.uppercase_variations * match.l33t_variations * reversed_variations;\n  }\n  static uppercase_variations(match) {\n    let chr;\n    const word = match.token;\n    if (word.match(this.ALL_LOWER) || word.toLowerCase() === word) {\n      return 1;\n    }\n    // a capitalized word is the most common capitalization scheme,\n    // so it only doubles the search space (uncapitalized + capitalized).\n    // allcaps and end-capitalized are common enough too, underestimate as 2x factor to be safe.\n    for (let regex of [this.START_UPPER, this.END_UPPER, this.ALL_UPPER]) {\n      if (word.match(regex)) {\n        return 2;\n      }\n    }\n    // otherwise calculate the number of ways to capitalize U+L uppercase+lowercase letters\n    // with U uppercase letters or less. or, if there's more uppercase than lower (for eg. PASSwORD),\n    // the number of ways to lowercase U+L letters with L lowercase letters or less.\n    const U = (() => {\n      const result2 = [];\n      for (chr of Array.from(word.split(''))) {\n        if (chr.match(/[A-Z]/)) {\n          result2.push(chr);\n        }\n      }\n      return result2;\n    })().length;\n    const L = (() => {\n      const result3 = [];\n      for (chr of Array.from(word.split(''))) {\n        if (chr.match(/[a-z]/)) {\n          result3.push(chr);\n        }\n      }\n      return result3;\n    })().length;\n    let variations = 0;\n    for (let i = 1, end = Math.min(U, L), asc = 1 <= end; asc ? i <= end : i >= end; asc ? i++ : i--) {\n      variations += this.nCk(U + L, i);\n    }\n    return variations;\n  }\n  static l33t_variations(match) {\n    let chr;\n    if (!match.l33t) {\n      return 1;\n    }\n    let variations = 1;\n    for (var subbed in match.sub) {\n      // lower-case match.token before calculating: capitalization shouldn't affect l33t calc.\n      var unsubbed = match.sub[subbed];\n      var chrs = match.token.toLowerCase().split('');\n      const S = (() => {\n        const result2 = [];\n        for (chr of Array.from(chrs)) {\n          if (chr === subbed) {\n            result2.push(chr);\n          }\n        }\n        return result2;\n      })().length; // num of subbed chars\n      const U = (() => {\n        const result3 = [];\n        for (chr of Array.from(chrs)) {\n          if (chr === unsubbed) {\n            result3.push(chr);\n          }\n        }\n        return result3;\n      })().length; // num of unsubbed chars\n      if (S === 0 || U === 0) {\n        // for this sub, password is either fully subbed (444) or fully unsubbed (aaa)\n        // treat that as doubling the space (attacker needs to try fully subbed chars in addition to\n        // unsubbed.)\n        variations *= 2;\n      } else {\n        // this case is similar to capitalization:\n        // with aa44a, U = 3, S = 2, attacker needs to try unsubbed + one sub + two subs\n        const p = Math.min(U, S);\n        let possibilities = 0;\n        for (let i = 1, end = p, asc = 1 <= end; asc ? i <= end : i >= end; asc ? i++ : i--) {\n          possibilities += this.nCk(U + S, i);\n        }\n        variations *= possibilities;\n      }\n    }\n    return variations;\n  }\n}\nScoring.MIN_YEAR_SPACE = 20;\nScoring.REFERENCE_YEAR = new Date().getFullYear();\nScoring.KEYBOARD_AVERAGE_DEGREE = calc_average_degree(adjacency_graphs.qwerty);\n// slightly different for keypad/mac keypad, but close enough\nScoring.KEYPAD_AVERAGE_DEGREE = calc_average_degree(adjacency_graphs.keypad);\nScoring.KEYBOARD_STARTING_POSITIONS = (() => {\n  const result = [];\n  for (k in adjacency_graphs.qwerty) {\n    v = adjacency_graphs.qwerty[k];\n    result.push(k);\n  }\n  return result;\n})().length;\nScoring.KEYPAD_STARTING_POSITIONS = (() => {\n  const result1 = [];\n  for (k in adjacency_graphs.keypad) {\n    v = adjacency_graphs.keypad[k];\n    result1.push(k);\n  }\n  return result1;\n})().length;\nScoring.START_UPPER = /^[A-Z][^A-Z]+$/;\nScoring.END_UPPER = /^[^A-Z]+[A-Z]$/;\nScoring.ALL_UPPER = /^[^a-z]+$/;\nScoring.ALL_LOWER = /^[^A-Z]+$/;\n;\n//# sourceMappingURL=scoring.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}